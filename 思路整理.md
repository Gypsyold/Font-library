# GBK和GB2312写入和读出实现思路

## 编码存储格式​

GBK 编码为 **双字节（16 位）编码**，每个字符由 “高字节（第 1 字节）” 和 “低字节（第 2 字节）” 组成，字节范围定义如下：
高字节（H）：0x81 ~ 0xFE
低字节（L）：分两种情况：
	当高字节 0x81~0xA0 时，低字节 0x40~0xFE（不含 0x7F）
	当高字节 0xA1~0xFE 时，低字节 0x40~0xA0（不含 0x7F）+ 0xA1~0xFE（不含 0x7F）


这个汉字在Keil等编译器中看到的不是汉字，而是计算机编码。
比如说如果使用GBK编码/GB2312编码，这个 '中' 字计算机在GBK中识别的是高字节D6 低字节D0(这个可以在GBK编码表中查到)，并且GBK编码都是按这个顺序来编码的（这是规定的）。所以我们**只需要按这个顺序来存储，按顺序来读取**就可以轻松在水墨屏或者其他显示器中来显示汉字了，不需要去遍历整个字库，减轻CPU负担。

由于**GBK 完全向上兼容 GB2312**，GBK是在GB2312基础上新增了大量汉字等，我是使用了GBK的方式来写入和读取的GB2312，修改后同样完全兼容。



## GBK地址偏移计算

首先存储要按GBK编码顺序存储，仓库提供的FontMaker这个软件中的GBK就是按编码顺序来写的。

之后读出的时候使用地址偏移：

```c
    //提取GBK双字节编码
    GBKH = *(s);     		// 高字节
    GBKL = *(s + 1); 		// 低字节
   
    //校验GBK编码有效性
    if (GBKH < 0x81 || GBKH > 0xFE || 
        GBKL < 0x40 || GBKL > 0xFE || 
        GBKL == 0x7F)
    {
        return;	//如果成立则是无效的GBK编码，直接返回
    }

    //计算地址偏移
    if (GBKL < 0x7F)
    {
        Addr_offset = ((GBKH - 0x81) * 190 + (GBKL - 0x40));
    }
    else
    {
        Addr_offset = ((GBKH - 0x81) * 190 + (GBKL - 0x41));
    }
//之后的起始写入地址 + 这个Addr_offset偏移就得到了该字模的起始位置，读取对应大小的字节，就读出了对应汉字字模
//读出字模后在显示屏上显示就可以了
```



## GB2312地址偏移计算

同样，GB2312需要按顺序存储，仓库提供的FontMaker这个软件中的GB2312也是按编码顺序来写的

由于GB2312只有

高字节（H）：0xB0~0xF7（共 58 个），低字节（L）：0xA1~0xFE（共 94 个），
不像GBK那么多，所以使用之前的偏移会导致前面空很多，我们需要减去A1之前的

```c
    //提取GB2312双字节编码
    GBKH = *(s);   			// 高字节
    GBKL = *(s + 1); 		// 低字节
	
    //校验GB2312编码有效性
	if (GBKH < 0xB0 || GBKH > 0xF7 ||  // 高字节范围：0xB0~0xF7（共58个）
		GBKL < 0xA1 || GBKL > 0xFE)    // 低字节范围：0xA1~0xFE（共94个）
    {
        return;				//如果成立则是无效的GB2312编码，直接返回
    }

//方法1：（现在使用的）
    // 计算地址偏移，移用GBK的公式
    if (GBKL < 0x7F)
    {
        Addr_offset = ((GBKH - 0x81) * 190 + (GBKL - 0x40));
    }
    else
    {
        Addr_offset = ((GBKH - 0x81) * 190 + (GBKL - 0x41));
    }
   

	// GB2312的偏移修正逻辑
    Addr_offset -= 6176; //需要减去前面没有的编码字
    if (GBKH > 0xA1)  //每个区有94个字，并且用190分隔开每个区，故换高字节之后减去96的倍数
	{
        uint8_t temp = GBKH - 0xA1;
        Addr_offset = Addr_offset - temp * 96;
    }

//方法2：
	//换用GB2312地址偏移的公式：
uint32_t Addr_offset = (GBKH - 0xB0) * 94 + (GBKL - 0xA1);
//使用这个地址的话需要注意！！！存储也要更改，存储也要根据这个更改顺序


//同样计算出偏移后，起始写入地址 + 这个Addr_offset偏移就得到了该字模的起始位置，读取对应大小的字节，就读出了对应汉字字模
//读出字模后在显示屏上显示就可以了
```

再次注意，要写入和读出的地址要对应起来，“GBK编码 -> 地址偏移 ”的对应关系

写入的时候也要注意，同一页中如果页中**任何一个地址**已经被写过（即存在非`0xFF`的数据），**后续对该页的页编程操作会静默失败**